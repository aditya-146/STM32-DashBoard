#include "GY_521.h"

uint8_t Z_Data[2];
int16_t Z_Raw;
float Az_G;
float Tilt_Deg;
float Relative_Tilt;
float Tilt_Offset;

 HAL_StatusTypeDef GY521_Connection(){
	 HAL_StatusTypeDef ret = HAL_I2C_IsDeviceReady(&hi2c1, (0x68 << 1) + 0, 1, 100);
	 return ret;
 }

 void GY521_Config(){
	 //Config gyros range
	 uint8_t temp_data = 0b00001000;
	 ret = HAL_I2C_Mem_Write(&hi2c1, (0x68 << 1) + 0, 27, 1, &temp_data, 1, 100);

	 //Config acc range
	 temp_data = 0b00000000;
	 ret = HAL_I2C_Mem_Write(&hi2c1, (0x68 << 1) + 0, 28, 1, &temp_data, 1, 100);

	 //Remove device from sleep mode and config temp sensor
	 temp_data = 0;
	 ret = HAL_I2C_Mem_Write(&hi2c1, (0x68 << 1) + 0, 107, 1, &temp_data, 1, 100);
 }

 float GY521_Calculate_Offset(){
	 HAL_I2C_Mem_Read(&hi2c1, (0x68 << 1), 63, 1, Z_data, 2, 100);
	 Z_Raw = ((int16_t)Z_data[0] << 8) | Z_data[1];
	 Az_G = Z_Raw / 16384.0f;

	 // Clamp just in case
	 if (Az_G >  1.0f) Az_G =  1.0f;
	 if (Az_G < -1.0f) Az_G = -1.0f;

	 Tilt_Offset = acosf(Az_G) * (180.0f / PI);
	 return Tilt_Offset;
 }

 float GY521_Calculate_Tilt(float Tilt_Offset){
	 HAL_I2C_Mem_Read(&hi2c1, (0x68 << 1) + 1, 63, 1, Z_data, 2, 100);
	 Z_Raw = (((int16_t)Z_data[0] << 8) + Z_data[1]);

	 Az_G = Z_Raw / 16384.0f;

	// clamp to avoid NaN
	if (Az_G >  1.0f) Az_G =  1.0f;
	if (Az_G < -1.0f) Az_G = -1.0f;

	Tilt_Deg = acosf(Az_G) * (180.0f / PI);

	// Subtract initial offset
	Relative_Tilt = fabsf(Tilt_Deg - Tilt_Offset);
	return Relative_Tilt;
 }


